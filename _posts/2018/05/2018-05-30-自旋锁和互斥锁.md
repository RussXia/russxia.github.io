---
layout: blog
title: "自旋锁和互斥锁"
catalog: true
tag: [计算机基础,2018]
---
# 自旋锁和互斥锁

## 自旋锁的由来

计算机系统资源总是有限的，有些资源需要互斥访问，因此就有了锁机制，只有获得锁的线程才能访问资源。锁保证了每次只有一个线程可以访问资源。

当线程申请一个已经被其他线程占用的锁，就会出现两种情况。一种是没有获得锁的线程会阻塞自己，等到锁被释放后再被唤起，这就是互斥锁；另一种是没有获得锁的线程一直循环在那里看是否该锁的保持者已经释放了锁，这就是自旋锁。

## 对自旋锁和互斥锁的认识

自旋锁：与互斥锁类似，但是互斥锁是sleeping-running的锁，自旋锁是一种running的锁，

自旋锁的所在线程不会被挂起，而是不断的消耗cpu时间，而互斥锁所在线程则会直接被挂起，不再浪费cpu时间。

频繁的切换线程上下文，是一个巨大的开销；但是长时间的占用cpu资源，也是浪费资源。所以需要针对实际情况有选择的选用。

如果是多核处理器，预计线程等待锁的时间比较短，短到比线程切换两次上下文的时间还要短，那么肯定是使用自旋锁比较合算

如果是单核，不建议使用自旋锁(即使是在等待锁的
情况下，线程依然占用cpu的资源。只能等待解锁。)

如果加锁的代码经常被调用，但竞争的情况很少的话，那么自旋锁的开销相对于互斥锁的开销要小